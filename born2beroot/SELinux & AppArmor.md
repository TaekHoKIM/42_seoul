
[SELinux 관련링크](https://lesstif.gitbook.io/web-service-hardening/selinux)
# 접근통제
접근 통제 : 디렉토리, 파일, 네트워크 소켓 등 ==시스템자원==을 적절한 권한을 가진 사용자나 그룹이 접근하고 사용할 수 있도록 통제하는 것

객체( object ) : 시스템 자원
주제  ( subject ) : 자원에 접근하는 사용자나 그룹

2가지 방식이 존재
## DAC (Discretionary Access Control) - 임의적 접근통제

**시스템 객체에 대한 접근은 사용자와 그룹의 신분을 기준으로 통제하는 방식**
- 객체의 소유자가 다른 주체의 접근권한을 부여하는 방식
-> ==root는 모든 시스템의 객체의 소유자== -> 다른 user들에게 접근 할 수 있는 권한을 조정함
-> ==user는 객체의 소유자가 못되냐?== => root가 객체의 소유권한을 user에게 부여하면 user도 객체의 소유자가 되서 객체의 접근 권한을 user1, user2에게도 부여할 수 있음
- 유닉스나 윈도우등에서 기본적인 접근 통제방식으로 사용
- 소유자 권한을 탈취당하면 모든 객체의 권한을 가지게 됨
- 특히 root를 탈취당하면 모든 권한을 가짐 (생기는 문제점은 다음과 같음)
	1. setuid / setgid 문제 -> setuid,setgid는 사용자가 사용자가 속한 그룹이나 소유자의 권한으로 동작하게 하는 비트임 -> DAC 방식은 setuid 보안을 해결할 수 없음 ( setuid는 필요한 비트 )
	2. well-known port daemon 문제 -> 특정한 쓰임새에 따라 미리 지정해둔 1024 미만의 포트번호로 루트만 사용할 수 있는 포트번호임 -> 데몬 서비스는 루트의 권한으로 작동함 -> 데몬 서비스를 이용해서 루트의 권한을 가져올 수 도 있음

## MAC ( Mandatory Access Control ) - 강제적 접근통제

__미리 정해진 정책에 따라 ==주체의 허용권한과 객체의 허용권한==을 비교하여 접근하는 통제 모델__
- 소유자라고 할 지라도 정책에 어긋나면 객체에 접근 할 수 없음
- well-known port daemon 문제에서 해당 포트의 권한을 탈취해도 그 포트의 권한만으로 모든 객체에 접근 할 수 없음 -> 접근이 허용된 일부 객체에만 접근이 가능함 ( 2차 피해를 줄일 수 있음 )
- 단, 구현이 복잡하고 설정이 까다로움, 시스템 관리자가 모델에 대해서 이해가 깊어야 함
- 중앙집중적이고 안정적인 관리 가능, But 관리가 까다롭고 보수적인고 경직적임 -> 보안시설이나 군시설에 주로 사용


# SELinux
__SELinux : Security-Enhanced Linux__
 
==MAC== 기반의 보안 커널을 사용한 리눅스 ( 커널 레벨의 보안 모듈임 )
- RHEL 기반의 배포판에서 포함되어 있음 ( Red Hat 계열 Linux 커널에 포함되었다고 보면 됨 )
- 기존 접근 통제 방식 ( DAC )보다 먼저 동작함 -> 소유자여도 자신 소유 폴더나 파일에 접근이 안될 수 있음
- "최소 권한" 원칙을 기반으로 함
- ==모든 리소스 ( 파일, 프로세스, 디렉토리, 포트 등)에 SELinux context라는 레이블이 붙어있음==
-> ==모든 리소스에 붙어있는 context에 맞지 않는 접근은 모두 차단== -> 새로운 프로세스를 만들 경우에 필요한 모든 리소스의 context를 변경해줘야 됨
-> 접근하려는 주체를 판단하는 방법은  ==주체의 context랑 자원의 context를 매칭==하고 매칭 규칙은 selinux 정책에 따라 결정됨
## SELinux 의 장점
- 사전 정의된 접근 통제 정책을 사용 - 기본적으로 정의된 접근 통제방식으로 DAC에서의 문제점인 setuid나 well-known port daemon 문제를 걱정하지 않아도 됨
- 기본적으로 ==Deny ALL, Permit Some== 정책이어서 잘못된 설정을 최소화함 - 필요한 것들을 허용하는 방식이어서 잘못된 접근이 나올 수 없음
- 권한 상승 공격으로 인한 취약점 감소 - DAC와 반대로 높은 권한을 가져도 접근 할 수 있는 적기 때문에 보안에 더욱 좋음
- 잘못된 설정과 버그로부터 시스템 보호 - 예를 들어, 버퍼오버플로 공격의 경우 어플리케이션이 메모리에 이있는 코드를 실행할 수 없도록 통제함 -> 쉘을 얻을 수 없음

## SELinux 의 한계
- SELinux의 주 목표는 2차 피해를 막는 것
- 침입차단 시스템 (IPS : Intrusion Protection System), 침입탐지 시스템 ( IDS : Intrusion Detection System) 과는 다름

## SELinux 동작
![](https://cloud.githubusercontent.com/assets/404534/12506805/d187db34-c134-11e5-85e3-76a71fd3ea9a.png)

-> 커널에서 처리를 함 - 속도를 위해 정책의 내용은 커널 내부의 AVC( Access Vector Cache )라는 이름으로 캐싱함

### 3가지 모드가 존재
1. enforce : 기본 설정이고, 보안 정책에 위반되는 모든 액션을 차단함
2. permissive : 정책에 위반되는 액션에 대한 경고를 하고 차단을 하지는 않음, 로그를 기록함
3. disable : SELinux 자체를 사용하지 않는 모드
-> enforce , permissive는 setenforce 0, setenforce 1 명령어로 변경 가능
-> disable은 /etc/selinux/config에서 SELINUX = disabled로 설정하고 재부팅 하면됨
=> 다시 활성화 할 때는 부팅 시간이 오래걸림 ( 모든 리소스에 보안 레이블을 추가해야 돼서 )

# AppArmor
AppArmor - linux 보안 모듈 ( 주로 debian 계열에서 사용 SELinux는 Red Hat 계열에서 사용)

- 보통 apparmor가 ==사용하기 쉽고 간단함== -> 비활성화 잘 안함 ( 하지만, selinux는 사용하기 복잡해서 비활성화를 많이 함 ) -> 더 많은 제어를 위해서라면 selinux를 사용
- AppArmor는 ==프로필==을 사용하여 접근권한을 관리함 -> 프로그램에 프로필을 붙여서 접근 할 수 있는 자원을 제한해둠 
- 프로필의 ==접근 가능한 자원은 경로를 기반==으로 설정함 -> 주체가 필요한 자원의 경로를 프로필에 설정함
- 주체의 프로필에 존재하는 경로의 자원만 접근이 가능함

## AppArmor 랑 SELinux 차이

- apparmor는 주체에 프로필을 설정함  / selinux는 모든 자원에  레이블을 설정함
- apparmor는 주체에 필요한 자원을 프로필에 ==경로를 기반==으로 설정 / selinux는 모든 자원과 주체에 ==레이블==이 존재해서 둘 간의 context를 매칭해서 접근을 결정함
